<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Time Tracker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body { padding: 24px; }
    td, th { vertical-align: middle; }
    .task-input { min-width: 260px; }
    .category-select { min-width: 180px; }
    code { font-size: 0.9em; }

    tr.current-slot {
      background-color: #e9f7ef; /* very light green */
      outline: 2px solid #b7e4c7;
      outline-offset: -2px;
    }

    .icon-btn {
      width: 32px;
      height: 28px;
      padding: 0;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
  </style>
</head>
<body>
<div class="container">
  <div class="d-flex flex-wrap align-items-center gap-3 mb-3">
    <h1 class="h4 mb-0">Time Tracker</h1>

    <input id="dateInput" type="date" class="form-control" style="max-width: 180px;">

    <button id="toggleBtn" class="btn btn-outline-secondary btn-sm">
      Show full day
    </button>

    <span id="status" class="text-muted small"></span>
  </div>

  <div class="table-responsive">
    <table class="table table-sm table-hover">
      <thead class="table-light">
        <tr>
          <th style="width:120px;">Start</th>
          <th style="width:120px;">End</th>
          <th>Task</th>
          <th style="width:220px;">Category</th>
          <th style="width:90px;" class="text-center">IsWork</th>
          <th style="width:90px;" class="text-center">Actions</th>
        </tr>
      </thead>
      <tbody id="tbody"></tbody>
    </table>
  </div>
</div>

<script>
(() => {
  // ================== CONFIG ==================
  const API_BASE = "http://localhost:31313/api/timetracker"; // <-- replace
  const API = {
    entries: () => `${API_BASE}/tasks`,
    categories: () => `${API_BASE}/categories`,
    putEntry: (id) => `${API_BASE}/task/${encodeURIComponent(id)}`,
    postEntry: () => `${API_BASE}/task`,
    deleteEntry: (id) => `${API_BASE}/task/${encodeURIComponent(id)}`,
    settings: () => `${API_BASE}/settings`,
  };

  // Default visible range: 08:45â€“17:15 (i.e., last slot starts 17:00)
  // ================== SETTINGS ==================
  let SLOT_DURATION = 15;
  let WORKDAY_START = "08:45"; // First slot start
  let WORKDAY_END   = "17:15"; // Last slot start

  async function loadSettings() {
    const settings = await get(API.settings());

    if (Number.isFinite(settings.duration)) SLOT_DURATION = settings.duration;
    if (typeof settings.startTime === "string") WORKDAY_START = settings.startTime;
    if (typeof settings.endTime === "string") WORKDAY_END = settings.endTime;
  }

  // ================== STATE ==================
  let showFullDay = false;
  let rows = [];        // current visible rows
  let categories = [];
  const saveTimers = new Map();
  let clipboard = null;
  let copyMode = false;

  // ================== DOM ==================
  const tbody = document.getElementById("tbody");
  const dateInput = document.getElementById("dateInput");
  const status = document.getElementById("status");
  const toggleBtn = document.getElementById("toggleBtn");

  // ================== TIME HELPERS ==================
  const pad = n => String(n).padStart(2, "0");

  function toMinutes(hhmm) {
    const [h, m] = hhmm.split(":").map(Number);
    return h * 60 + m;
  }

  function addMinutes(hhmm, mins) {
    const total = (toMinutes(hhmm) + mins) % 1440;
    return `${pad(Math.floor(total / 60))}:${pad(total % 60)}`;
  }

  function slotsBetween(startHHMM, endHHMM) {
    // end is exclusive
    const start = toMinutes(startHHMM);
    const end = toMinutes(endHHMM);
    const slots = [];
    for (let t = start; t < end; t += SLOT_DURATION) {
      slots.push(`${pad(Math.floor(t / 60))}:${pad(t % 60)}`);
    }
    return slots;
  }

  function getVisibleSlots() {
    return showFullDay
      ? slotsBetween("00:00", "24:00")
      : slotsBetween(WORKDAY_START, WORKDAY_END);
  }

  function currentTimeSlotHHMM() {
    const now = new Date();
    const mins = now.getHours() * 60 + now.getMinutes();
    const slotStart = Math.floor(mins / SLOT_DURATION) * SLOT_DURATION;
    return `${pad(Math.floor(slotStart / 60))}:${pad(slotStart % 60)}`;
  }

  // ================== UI HELPERS ==================
  function rowHasData(row) {
    return row.task.trim() !== "" || row.category.trim() !== "" || row.isWork !== false;
  }

  function setCopyMode(sourceRowOrNull) {
    if (!sourceRowOrNull) {
      clipboard = null;
      copyMode = false;
    } else {
      clipboard = {
        sourceStart: sourceRowOrNull.start,
        task: sourceRowOrNull.task,
        category: sourceRowOrNull.category,
        isWork: sourceRowOrNull.isWork
      };
      copyMode = true;
    }
    updateCopyPasteUI();
  }

  function updateCopyPasteUI() {
    for (const row of rows) {
      const tr = tbody.querySelector(`tr[data-start="${row.start}"]`);
      if (!tr) continue;

      const copyBtn = tr.querySelector(`button[data-action="copy"]`);
      const pasteBtn = tr.querySelector(`button[data-action="paste"]`);

      const isSource = copyMode && clipboard?.sourceStart === row.start;
      const canCopy = rowHasData(row);

      // ---------- COPY BUTTON ----------
      if (copyBtn) {
        if (!copyMode) {
          // Normal mode â†’ show copy buttons normally
          copyBtn.classList.remove("d-none");
          copyBtn.disabled = !canCopy;
          copyBtn.classList.remove("btn-primary");
          copyBtn.classList.add("btn-outline-secondary");
        } else {
          if (isSource) {
            // Only show the selected row's copy button
            copyBtn.classList.remove("d-none");
            copyBtn.disabled = false;
            copyBtn.classList.remove("btn-outline-secondary");
            copyBtn.classList.add("btn-primary"); // visually active
          } else {
            // Hide all other copy buttons
            copyBtn.classList.add("d-none");
          }
        }
      }

      // ---------- PASTE BUTTON ----------
      if (pasteBtn) {
        if (copyMode && !isSource) {
          pasteBtn.classList.remove("d-none");
          pasteBtn.disabled = false;
        } else {
          pasteBtn.classList.add("d-none");
        }
      }
    }
  }

  function applyClipboardToRow(row) {
    if (!clipboard) return;

    row.task = clipboard.task ?? "";
    row.category = clipboard.category ?? "";
    row.isWork = (clipboard.isWork ?? false) === true;

    // Update DOM inputs for this row only (no render)
    const tr = tbody.querySelector(`tr[data-start="${row.start}"]`);
    if (tr) {
      const taskInput = tr.querySelector(`input[data-field="task"]`);
      const catSelect = tr.querySelector(`select[data-field="category"]`);
      const isWorkCb  = tr.querySelector(`input[data-field="isWork"]`);

      if (taskInput) taskInput.value = row.task;
      if (catSelect) catSelect.value = row.category;
      if (isWorkCb)  isWorkCb.checked = row.isWork;
    }

    // Save the row (creates record if needed)
    saveRow(row);
  }

  // ================== API HELPERS ==================
  async function get(url) {
    const r = await fetch(url, { headers: { "Accept": "application/json" } });
    if (!r.ok) throw new Error(`GET ${r.status}`);
    return r.json();
  }

  async function put(url, body) {
    const r = await fetch(url, {
      method: "PUT",
      headers: { "Content-Type": "application/json", "Accept": "application/json" },
      body: JSON.stringify(body)
    });
    if (!r.ok) throw new Error(`PUT ${r.status}`);
    return r.json();
  }

  async function post(url, body) {
    const r = await fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json", "Accept": "application/json" },
      body: JSON.stringify(body)
    });
    if (!r.ok) throw new Error(`POST ${r.status}`);
    return r.json();
  }

  async function del(url) {
    const r = await fetch(url, {
      method: "DELETE",
      headers: { "Accept": "application/json" }
    });
    if (!r.ok) throw new Error(`DELETE ${r.status}`);
  }

  // ================== RENDER ==================
  function escapeHtml(s) {
    return String(s ?? "").replace(/[&<>"']/g, m =>
      ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m])
    );
  }

  function render() {
    tbody.innerHTML = rows.map(r => `
      <tr data-start="${r.start}">
        <td><code>${r.start}</code></td>
        <td><code>${addMinutes(r.start, SLOT_DURATION)}</code></td>

        <td>
          <input class="form-control form-control-sm task-input"
                 data-field="task"
                 value="${escapeHtml(r.task)}"
                 placeholder="Taskâ€¦">
        </td>

        <td>
          <select class="form-select form-select-sm category-select"
                  data-field="category">
            <option value=""></option>
            ${categories.map(c => `
              <option value="${escapeHtml(c.id)}" ${c.id === r.category ? "selected" : ""}>
                ${escapeHtml(c.name)}
              </option>
            `).join("")}
          </select>
        </td>

        <td class="text-center">
          <input type="checkbox"
                 class="form-check-input"
                 data-field="isWork"
                 ${r.isWork ? "checked" : ""}>
        </td>

        <td class="text-center">
          <div class="d-inline-flex gap-1">
            <!-- Copy -->
            <button
              type="button"
              class="btn btn-sm btn-outline-secondary icon-btn"
              data-action="copy"
              title="Copy this row"
              ${rowHasData(r) ? "" : "disabled"}>
              ðŸ“‹
            </button>

            <!-- Paste (hidden unless copy mode is active; we'll toggle via JS) -->
            <button
              type="button"
              class="btn btn-sm btn-outline-success icon-btn d-none"
              data-action="paste"
              title="Paste into this row">
              ðŸ“¥
            </button>

            <!-- Clear -->
            <button
              type="button"
              class="btn btn-sm btn-outline-danger icon-btn"
              data-action="clear"
              ${r.id ? "" : "disabled"}
              title="Clear this time slot">
              âœ•
            </button>
          </div>
        </td>
      </tr>
    `).join("");
    highlightCurrentSlot();
    updateCopyPasteUI();
  }

  function highlightCurrentSlot() {
    // Clear existing highlight
    tbody.querySelectorAll("tr.current-slot")
        .forEach(tr => tr.classList.remove("current-slot"));

    const slot = currentTimeSlotHHMM();

    const row = tbody.querySelector(`tr[data-start="${slot}"]`);
    if (row) {
      row.classList.add("current-slot");
    }
  }

  function enableClearButtonForStart(start) {
    const tr = tbody.querySelector(`tr[data-start="${start}"]`);
    if (!tr) return;
    const btn = tr.querySelector(`button[data-action="clear"]`);
    if (!btn) return;
    btn.disabled = false;
  }

  // ================== LOAD / OVERLAY ==================
  function showError(msg) {
    console.error(msg);
    status.textContent = msg;
  }

  function buildBlankVisibleGrid() {
    rows = getVisibleSlots().map(start => ({
      id: undefined,
      start,
      task: "",
      category: "",
      isWork: false
    }));
  }

  async function loadDay(date) {
    status.textContent = "Loadingâ€¦";

    // Always show blank visible rows immediately
    buildBlankVisibleGrid();
    render();

    // Try categories
    try {
      categories = await get(API.categories());
    } catch (e) {
      categories = [];
      showError("Warning: categories failed to load (dropdown empty).");
    }
    render();

    // Try entries overlay (entries API can return [] and that's fine)
    try {
      const existing = await post(API.entries(), { filters: [{ Day: date }] });
      const byStart = new Map(existing.map(e => [e.start, e]));

      for (const row of rows) {
        const e = byStart.get(row.start);
        if (!e) continue;

        row.id = e.id;
        row.task = e.task ?? "";
        row.category = e.category ?? "";
        row.isWork = (e.isWork ?? true) === true;
      }

      status.textContent = "";
      render();
    } catch (e) {
      showError("Warning: entries failed to load (showing blank rows).");
    }
  }

  // ================== SAVE (per-row) ==================
  function buildPayload(row) {
    return {
      date: dateInput.value,
      start: row.start,
      duration: SLOT_DURATION,
      task: row.task,
      category: row.category,
      isWork: row.isWork,
    };
  }

  function shouldPersist(row) {
    // Avoid creating records for empty rows (adjust if you want every slot saved)
    return row.task.trim() !== "" || row.category.trim() !== "" || row.isWork === false;
  }

  function debounceSave(row, delay = 1000) {
    const key = row.start;
    if (saveTimers.has(key)) clearTimeout(saveTimers.get(key));
    saveTimers.set(key, setTimeout(() => {
      saveTimers.delete(key);
      saveRow(row);
    }, delay));
  }

  async function saveRow(row) {
    if (!shouldPersist(row)) {
      status.textContent = "";
      return;
    }

    status.textContent = `Saving ${row.start}â€¦`;
    const payload = buildPayload(row);

    try {
      if (row.id) {
        const updated = await put(API.putEntry(row.id), payload);
        row.id = updated?.id ?? row.id;
      } else {
        const created = await post(API.postEntry(), payload);
        row.id = created?.id;
        if (row.id) enableClearButtonForStart(row.start);
      }
      status.textContent = "";
    } catch (e) {
      console.error(e);
      status.textContent = `Save failed (${row.start})`;
    }
  }

  // ================== EVENTS ==================
  function findRow(start) {
    return rows.find(r => r.start === start);
  }

  tbody.addEventListener("input", (e) => {
    const target = e.target;
    const tr = target?.closest?.("tr");
    if (!tr) return;

    const row = findRow(tr.dataset.start);
    if (!row) return;

    if (target.dataset.field === "task") {
      row.task = target.value;
      updateCopyPasteUI();
      debounceSave(row);
    }
  });

  tbody.addEventListener("change", (e) => {
    const target = e.target;
    const tr = target?.closest?.("tr");
    if (!tr) return;

    const row = findRow(tr.dataset.start);
    if (!row) return;

    if (target.dataset.field === "category") row.category = target.value;
    if (target.dataset.field === "isWork") row.isWork = target.checked;

    updateCopyPasteUI();
    saveRow(row);
  });

  toggleBtn.addEventListener("click", async () => {
    showFullDay = !showFullDay;
    toggleBtn.textContent = showFullDay ? "Show workday only" : "Show full day";
    await loadDay(dateInput.value); // rebuild visible rows + overlay entries
  });

  tbody.addEventListener("click", async (e) => {
    const btn = e.target.closest("button[data-action]");
    if (!btn) return;

    const action = btn.getAttribute("data-action");
    const tr = btn.closest("tr");
    if (!tr) return;

    const start = tr.dataset.start;
    const row = findRow(start);
    if (!row) return;

    if (action === "copy") {
      // Toggle copy mode on/off when clicking the source row copy again
      const isSource = copyMode && clipboard?.sourceStart === row.start;
      if (isSource) {
        setCopyMode(null);
      } else {
        if (!rowHasData(row)) return; // should already be disabled, but safe
        setCopyMode(row);
      }
      return;
    }

    if (action === "paste") {
      if (!copyMode || !clipboard) return;
      // Don't paste onto the source row (paste button hidden anyway)
      if (clipboard.sourceStart === row.start) return;

      applyClipboardToRow(row);
      return;
    }

    if (action === "clear") {
      if (!confirm(`Clear entry for ${start}?`)) return;

      try {
        if (row.id) {
          await del(API.deleteEntry(row.id));
        }

        row.id = undefined;
        row.task = "";
        row.category = "";
        row.isWork = false;

        render();
        status.textContent = "";
      } catch (err) {
        console.error(err);
        status.textContent = `Failed to clear ${start}`;
      }
    }
  });

  // ================== INIT ==================
  function todayISO() {
    const d = new Date();
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
  }

  async function init() {
    // Load settings first (but don't hard-fail)
    try {
      await loadSettings();
    } catch (e) {
      console.warn("Settings load failed; using defaults.", e);
    }
    
    dateInput.value = todayISO();
    dateInput.addEventListener("change", () => loadDay(dateInput.value));

    // initial label
    toggleBtn.textContent = "Show full day";
    loadDay(dateInput.value);
    setInterval(highlightCurrentSlot, 60 * 1000);
  }

  init();
})();
</script>
</body>
</html>
